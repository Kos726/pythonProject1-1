# открываем класс - нечто, что содержит набор характеристик и действий некого объекта, например собаки:

class Dog: # имя класса всегда пишется с заглавной буквы
    pass    # функция pass используется только для того,
            # чтоб выполнялась любая другая верхняя по иерархии функция,
            # но при этом ничего внутри не происходило

# внутри класса создаются атрибуты, которые могут быть
    # - статичные - не изменяемые
    # - динамические - изменяемые функционально

    default_color = "Blue" # пример статического атрибута. Получить доступ к нему можно не создавая объект класса Dog

# ниже описывается динамические атрибуты name и age
    def __init__(self, name, age):  # init - конструктор, который инициирует набор атрибутов и характеристик
                                    # def в данном случае определяет действие конструктора,
        self.name = name            # определили название атрибута - имя
        self.age = age              # определили вторую атрибута - возраст

# вывод статического атрибута - цвета по умолчанию
print("Цвет по умолчанию: ", Dog.default_color)
# поменяем цвет
Dog.default_color = "Red"
print("Фактический цвет: ", Dog.default_color)
# Однако работать напрямую с атрибутами не рекомендуется,
# лучше работать со свойствами

# работа с динамическими атрибутами объекта
farfalla = Dog("Eva", 1.5)   # только сейчас присвоили некоторому объекту характеристики возраст и имя

# однако обращения к функции еще нет, чтоб к ней обратиться нужна другая командла, например print

print(farfalla.name) # обращаемся к нашему объекту, для вывода имени
print(farfalla.age) # обращаемся к нашему объекту, для вывода возраста

# выведем иначе
print(f'Привет, я {farfalla.name}, и мне {farfalla.age} годика(-ов)')

# т.е. действия с классми и функциями и атрибутами ничем не отличается от действия с обычными функциями,
# за имсключением опеределенного синтаксиса

# можно переропределить значение характеристики, например, уточним возраст
farfalla.age = 1.6
print("Уточняем возраст: ", farfalla.age)

# конструкторы класса new и init
# new - конструктор класса
# init - инициализатор экземпляра, может использовтаься без new,
# т.к. в момент инициализации new создается автоматически

class Rectangle():
    def __new__(cls, *args, **kwargs):
        print("Hello from __new__")
        return super().__new__(cls) # super - функция возврата объекта посредника
    def __init__(self, wid, height):
        print("Hello from __init__")
        self.wid = wid
        self.height = height

rect = Rectangle(10, 20)
print(rect.wid)
print(rect.height)


# МЕТОДЫ внутри класса, это функция, находящаяся внутри класса.
class Person: # создали новый класс - человек

# Методы бывают трех видов/типов: статические, классовые и уровня класса (просто метод):
# статический метод создается с деккоратором @staticmethod

    @staticmethod # декоратор статического метода
    def ex_static_method(): # статический метод
        print("____Статический метод____")

    @classmethod # декоратор метода класса
    def ex_class_method(cls):
        print("____Метод класса____")

    def ex_method(self): # для метода уровня класса декоратор не требуется
        print("____Метод____")

# вывод для каждого вида методов свой - см ниже:

    def say_hello(self): # определили внутри функцию, она и есть метод
         print("Привет!") # внутри функции задали функицию - что делать с функцией иерархии выше

print(Person.ex_static_method()) # вывод для статического метода
print(Person.ex_class_method()) # вывод для метода класса

# для работы обычного метода нужен объект
m = Person() # создали объект
m.ex_method() # запустили объект

# таким образом, для
kostia = Person() # создали объект, сказав что он принадлежит к классу человека
kostia.say_hello() # применяем к нашему объекту метод


# если необходимо, чтобы метод обращшался со множеством параметров, они должны следовать после self
class Person_2:  # создали новый класс - человек
    def say_params(self, message, subject):  # определили внутри функцию, она и есть метод
            print(message, subject)  # внутри функции задали функицию - что делать с функцией иерархии выше

kos = Person_2()  # создали объект, сказав что он принадлежит к классу человека
kos.say_params("параметр 1", "параметр 2")  # применяем к нашему объекту метод

# по сути между методом и атрибутом нет разницы, отличие только в синтаксисе,
# например, посмотрим, как взаимодействуют атрибуты и методы
class Human:
    def __init__(self, name, age): # определили контруктор атрибутов
        self.name = name
        self.age = age
    def display_info(self): # определлди метотод - что делать с атрибутами
        print(f'Имя: {self.name}. Возраст: {self.age}')
# теперь нужно вновь опреедлить объект, который будет принадлежать к классу Human
son = Human("Alex", 10)
daughter = Human("Maya", 7)
# выведем на консоль информацию об объектах
son.display_info()
daughter.display_info()

# Деструктор - специфальный метолд, противоположный конструктору - удаляет созданую запись - очищаяя базу данных.

class Person_3:
    def __init__(self, name): # Создаем информацию о человеке
        self.name = name
        print("Создан человек с именем")
    def __del__(self): # удаляем информацию о человеке
        print("Удален человек с именем___")

tom = Person_3("Tom") # информация о человеке перестает существовать
print(tom)

#другой пример, когда объек создается в области некоторой функции и только
class Person_4:
    def __init__(self, name):
        self.name = name
        print("Создаем человека")
    def __del__(self):
        print("Удаляем человека")

def create_person(): # открываем функцию вне класса
    bob = Person_4("Bob") # создаем объект внутри функции

create_person()
print("Конец программы") # так как объект создан внутри функции, то его "жизнь" ограничена областью этой функции
